용어정리
사전적정의를 하기보다는 본인이 해본 경험을 바탕으로 해당 단어를 설명하기위해 노력할것.
위 설명이 어려운 경우, 사전적 정의라도 이야기 할 수 있어야함.

그래픽API
ㄴOepnGL: 범용OS용 그래픽라이브러리
ㄴㄴES: 모바일과 같은 저사양기기에서 작동할수있도록 만들어진 라이브러리
ㄴDriectX: Window전용 그래픽라이브러리

버텍스(정점): 3d모델을 나타내기위해 만들어진 점
버텍스버퍼: 이점들을 저장하는 버퍼
디바이스: 3d 디바이스 = GPU
디바이스초기화: 3d디바이스를 사용할 구조체를 초기화함.
버텍스버퍼 초기화: 버텍스들의 위치와 색상을 정해주고 배열을 GPU복사함.
랜더링:
텍스처코디(UV좌표): 버텍스마다 텍스처가 발릴 위치
빌보드: 카메라를 항상 바라보고 있는 평면
절두체: 카메라의 원근평면 을 포함한 시각범위 
높이맵: 지형을 나타내내기위하여 이미지에 색상정보를 활용하여 높이를 표시함.
행렬과 회전: 행렬의 3x3행렬은 각 원소의 값에 따라 축에 따른회전.
LOD: 카메라와의 거리에 따라 버텍스를 조절하여 랜더링 성능을 높ㅇ임
쿼트트리: 트리구조가 4개를 활용하여 평면위에 검색해야하는 범위를 나누어 검색속도를 높임.
옥타트리: 3차원구조에서 필요한 평면을 검색하여 범위를 나누어 검색속도를 빠라ㅡ게 처리하기위해 필요함.
컬링: 랜더링시에 불필요한 평면을 랜더링하지않는 것.

내적: 두백터 사이의 내각 크기를 구함.
외적: 두백터에 모두 수직인 벡터를 구함.
평면: 수학적 평면은 무한한 평면으로 원점과 방향을 가지고 있다.
평면과 점의 관계
ㄴ평면과 점이 예각이면 평면보다 위에 있다.
ㄴ평면과 점이 둔각이면 평면보다 아래 있다.
ㄴ평면과 점이 직각이면 평면에 걸처 있다.

랜더링파이프라인: 3d물체가 카메라에 그려지는 과정
ㄴ로컬 스페이스: 자기자신을 기준으로 위치를 나타내는 것.
ㄴ월드 스페이스: 세상을 기준으로 정렬되는 위치
ㄴ뷰 스페이스: 보이는 기준으로 물체의 위치를 나타내는 것.
ㄴ프로젝션 스페이스: 버텍스를 2d좌표로 그릴수있도록 위치를 나타내는 것.

batching:

라이브러리: 외부에서 제공되는 기능을 활용하여 개발하기 위한것.
ㄴ소스코드의 헤더파일만 공유하고 cpp파일을 빌드하여 lib파일로 빌드해서 제공하기도한다.
ㄴ빌드된 라이브러리는 하드웨어에 맞게 빌드가 된것만 사용이 가능하다.
링크: 소스코드가 빌드되고 사용할 lib를 연결시키는 것.
 
오픈소스: 소스코드를 누구나 볼수있고 사용할수 있도록 하는 진영\
네이티브프로그래밍: 자신의 플랫폼이 아닌 다른 플랫폼을 통해 프로그래밍을 할 수 있는 도구
NDK: 네이티브 개발 도구
ㄴ안드로이드에서 C/C++프로그래밍이 필요할때 사용하는 개발도구
JNK:
SDK(소프트웨어개발도구): 소프트웨어를 개발할때 필요한 도구들의 집합
adb: 안드로이드 기기에 연결하여 커멘드라인을 기기에 전송하여 조작 할수 있도록 돕는 콘솔프로그램
개발자모드: 기기를 일반적인 사용자가 아니라 개발자가 활용하기위해서 숨겨진옵션을 활성화한다.
그래들빌드: 안드로이드의 빌드설정을 조정 할 수 있는 스크립트.
AppData: 앱에서만 사용가능한 폴더, 앱에 필요한 파일을 쓰거나 읽는 것을 저장한다.
ㄴ앱에서 내앱폴더이외에 폴더에 접근 할수있다면?: 보안상 문제가 될수있으므로 허용하지않아야한다.
타겟API:
닷넷:
ㄴ모노:
ㄴIL2CPP:

C/C#에서 파일저장하고 읽기(텍스트, 바이너리형식)
C언어에서 시링얼라이즈 구현해보기

파일: 텍스트,바이너리 형식
ㄴ텍스트: 파일을 읽을수있는 글자로 저장하는 것(인코딩: UTF8, ANSI) 
ㄴ바이너리: 메모리를 그대로 저장하는 것.

시리얼라이즈: 객체를 버퍼화하여 저장한다.
버퍼: 어떤 데이터를 저장하기위해 만들어진 데이터 배열 
예) unsigned char butter[255]
ㄴ변수에 데이터가 있다면?  RAM
ㄴ파일로 데이터를 저장하면? ROM(HDD,SSD)


[네트워크]
포트포워딩:
루프백주소: 자신의 기기에 연결한다.


API: 
인터페이스: 
ㄴ프로그래밍: 함수, 라이브러리
ㄴ클래스: 설계를 한것대로 코드를 작성하도록 강제하는 것.
객체지향언어가 대두된 이유: 객체화 되어있으면 해당 객체를 찾아서 필요한 관련 함수를 찾아보면되기때문
객체지향: 
객체지향에서 설계가 중요한가?: 중요하지않음. 무경험자는 해당 경험이 없으므로, 
원칙에 위배되지않는 코드만 짜려고하다가 결국 무엇이 문제인지 모르는 원칙주의자가 됨.
그러나 자신이 설계를 하고 문제가 발생한것을 이해하는 사람은 다음과같은 행동을 당연히 하지않게됩니다.

라이브서비스를 할때 작업자가 설계자의 의도에 의해서 문제를 발생시키지않기위해서 알아두면 좋은것.
신입은 이것을 모른다는 가정을 해야한다. 안다는 착각에 빠져있기때문에, 설계로 모든 상황을 막아버리는 최악의 수를 두게된다.
그래서 코드를 짤때마다 설계를 변경해야하는 최악의 상황에 빠지게된다.

실무자들입자에서는 다음과 같은 경험이 있는 사람이 아니면 같이 일하고 싶어하지않는다.
그러나, 대부분의 신입들을 뽑으면 이것을 이론적으로 이해만 하는사람 대체적으로 생산성에 문제가 발생한다. 
그러므로 이러한 생산성을 갖추기위하여 프로젝트나 포트폴리오를 통하여 자신이 실무에서 어떤 대응을 해야하는지 이해하는 사람을 선호하게된다.
 

온라인게임 -> 라이브를 유지하며 기존의 코드를 유지보수. -> 엔진발전X 
싱글게임 -> 록맨1 > 2 기존의 코드를 개선시켜 새로운 작품을 만들면됨 -> 엔진발전O

윈도우는 초기에 모든 권한을 계정에 주고, 폴더접근을 제한하지않았기때문에, 파일을 변조할수있다. 
이 때문에 초기에 사용자에게 편리하게 사용할수있었지만 보안문제가 많았음.

WinAPI: 함수로 구성되어있음.
MFC: 마이크로소프트 기본 클래스. WinAPI의 함수를 클래스의 형태로 제공하는 것.

콜백: 뒤에서 부른다? 알수없는 곳에서 호출되고 있는 것. 함수에 주소값을 넘기면 필요할때 플랫폼(OS)에서 처리함.
콜: 함수호출.
메세지: 운영체제가 어떤 상황이 되면 보내주는 것.
WM_CREATE: 실행될때
WM_COMMAND: 버튼누를때
WM_PAINT: 창이 그려질때
WM_DESTROY: 종료될때
핸들러: 이벤트가 발생되는 조건을 지정하는 것
이벤트: 이전의 상태와 달라지는 것

오버라이딩: 
동적바인딩: 프로그램 실행 도중에 함수의 기능이 결정되는 것. (동적할당된 메모리에 따라 다름)
정적바인딩: 프로그램 실행(컴파일) 이전 함수의 기능이 결정되는것.


플렛폼: 서비스를 제공하는 주체. 예) 카카오, 네이버, 구글
ㄴ소프트웨어: 운영체제,SDK, 예) 윈도우, 안드로이드, 유니티, 아마존클라우드, 에저....
운영체제: 기기와 상관없이 운영체제가 설치되면 소프트웨어를 사용 할 수 있음.
드라이버: 운영체제에 맞게 하드웨어를 사용할수 있도록 돕는 프로그램.

오락실게임은 기판으로 제작됨. 하드웨어에 맞춰서 코드를 작성하는 시대.
기판: 오락기에 게임이 들어가있는 기판.
콘솔: 
크로스플랫폼: 
D3D의 대두: 풀스크린모드를 지원하여 모든 하드웨어를 게임이 온전하게 활용할수있도록 만듦.


빌드: 사용할 기기(플랫폼)에 맞게 실행할수있는 파일(컴파일)을 만드는 것.

SDK: 소프트웨어 개발도구


백도어: 정상적인 루트가 아닌 우회루트. 해킹할때 활용된다.

함수포인터: 함수의 주소값을 저장한다.

클라우드: 어떤 서비스를 제공하는데 그 아랫단의 로직은 중요하지않음.
클라우드게임서비스: 클라우드서비스안에서 게임이 실행됨.
DLL: 

버튼을 누르면 버튼의 텍스트를 변경하게 만든다.
데이터: 버튼 (객체) (변수)
알고리즘: 버튼을 누르면 버튼의 텍스트가 변경된다.(이벤트)

변수: 직업, 이름, 능력치 5개, 보너스포인트
이벤트: 클래스를 누르면 직업리스트가 뜬다.
스탯을 증감 시킬수 있다.
스탯을 분배하면 보너스포인트가 감소한다.
다시분배버튼 클릭시, 초기화된다.

구조를 이해하고 내가 필요한 코드를 어디에 넣어야할지 파악 할 수 있어야한다.

이벤트: 어떤사건이 일어나게되는 계기
ㄴwinAPI: 메세지(핸들러)를 발생시켜 해당 핸들러일 경우, 이벤트를 처리하도록 만듦.
ㄴMFC: 

헝가리안식표기:
콘솔을 활용한 이벤트 발생 경위추적

SDL검사:

x64: 64비트
x86: 32비트
ARM: 모바일 프로세서
포인터:
void포인터: 타입이 없는 포인터.
변수에 타입이 필요한 이유: 크기가 필요한 이유. 
변수에 표현범위가 있는 이유?: 이진수의 범위에 맞춰서 데이터를 맵핑되어있음.
간디가 폭력적인 이유?: 오버/언더플로우 때문
2^32 = 4g 
long Pointer: 2^32 타입의 포인터 (4g까지 표현가능)
printf할때 표현방법을 정해줘야하는 이유?
메모리는 데이터 덩어리일 뿐이고, 디코딩단계에서 어떻게 해석하느냐에 따라 달라진다.
치트엔진: 메모리를 읽어 값을 덮어쒸움.
메모리난독화: 
시리얼라이즈: 
동적할당:
정적할당: 
메모리누수: 동적할당된 메모리를 해제하지않으면, 메모리 누수가 발생하여, 할당할수없는 상태가 된다.
메모리페이징: 가용메모리는 있으나, 자투리 빈공간이 발생하여 더이상 메모리를 할당 할 수 없는 상태.

프로세스:
스레드:
테스크:
잡스케쥴러:
CPU에서 스레드 처리방식:
듀얼코어에서 게임처리방식:
멀티코어에서 게임처리방식:
오버헤드: 가장효율적인 처리시간에 비교해서 처리가 효률적이지 못해 생기는 문제
컨텍스트스위칭: 작업을 변경하기 위해서 준비하는 단계

코루틴:
비동기화프로그래밍: 같은 흐름내에서 처리하지않고 작동하는 처리로직.

캐싱:
버퍼링: 
교착상태:
선점/비선점:

static맴버는 객체없이 함수나 변수에 접근 할 수 있다.(싱글톤)
순수가상함수: 상속받는 자식클래스에서 반드시 선언해야한다.

일반화: 상속
실체화: 가상클래스를 상속받아 자식클래스를 만드는 것.
의존(사용):객채내부에 저장하지않고 사용함.
연관(has-a):객체내부에 참조를 저장함.

메모리누수검사를 통해 문제를 해결할수있다.
객체 설계시에 내부에 외부에서 동적할당객체를 받는것은 좋은 설계가 아니다.

호출스택: 
ㄴ스택오버플로우:
스마트포인터:
ㄴ쉐어드포인터:
ㄴ유니크포인터:
ㄴ위크니스포인터:
가비지컬렉터:

메모리와의 관계

C/C++
객체(=인스턴스): 메모리가 할당된 클래스의 변수
SingleObject objSingle; //정적할당객체(인스턴스) 변수의 타입에 따라 삭제되는 시기가 결정
SingleObject* pObjSingle = new SingleObject(); //동적할된 객체 동적할당해제
C#
객체: 인스턴스의 참조값을 저장하는 변수 
인스턴스: 클래스를 동적할당하여 만들어진 참조된 대상
예) 독수리가 참조하는 타겟인 플레이어 인스턴스는 타겟이 발견했을때만 추적한다.
독수리가 플레이어를 추적할때, 객체: 타겟이 담길 변수 인스턴스: 플레이어오브젝트
클래스: 객체는 참조자고 객체를 사용하려면 객체를 할당하거나 참조해야한다.
class SingleObject;
SingleObject objSingle = new SingleObject()
			 객체(참조자)

구조체: 객체가 정적할당된다. 스탯: 값을 복사해서 가져가므로 공유되는 문제가 발생하지않음.
struct SingleObject;
SingleObject objSingle = new SingleObject()
			 객체(정적할당)       생성자의 호출(객체에 값을 할당)
			 
상속할때 부모의 부분을 선언하지않아도되는 이유: 부모위에 자식객체에 추가 메모리를 할당한다.

정적할당된 메모리는 스택에 할당된다.
동적할당된 메모리는 힙에 할당된다.
스택오버플로우: 정적할당된 메모리가너무 많아져 스택의 크기보다 많이 할당함.
무한재귀에 스택오버플로우가 발생한다.
단순 반복이 많은 횟수 반복될때는 재귀를 사용해서는 안된다.

재귀를 써야하는 이유: 트리 -> 탐색 -> 스택을 사용하지않게하기위해 -> 함수가 호출될때마다 지역변수가 스택에 할당되어 이전의 데이터에 접근 할수 있어서.