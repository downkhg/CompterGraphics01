용어정리
사전적정의를 하기보다는 본인이 해본 경험을 바탕으로 해당 단어를 설명하기위해 노력할것.
위 설명이 어려운 경우, 사전적 정의라도 이야기 할 수 있어야함.

API: 
인터페이스: 
ㄴ프로그래밍: 함수, 라이브러리
ㄴ클래스: 설계를 한것대로 코드를 작성하도록 강제하는 것.
객체지향언어가 대두된 이유: 객체화 되어있으면 해당 객체를 찾아서 필요한 관련 함수를 찾아보면되기때문
객체지향: 
객체지향에서 설계가 중요한가?: 중요하지않음. 무경험자는 해당 경험이 없으므로, 
원칙에 위배되지않는 코드만 짜려고하다가 결국 무엇이 문제인지 모르는 원칙주의자가 됨.
그러나 자신이 설계를 하고 문제가 발생한것을 이해하는 사람은 다음과같은 행동을 당연히 하지않게됩니다.

라이브서비스를 할때 작업자가 설계자의 의도에 의해서 문제를 발생시키지않기위해서 알아두면 좋은것.
신입은 이것을 모른다는 가정을 해야한다. 안다는 착각에 빠져있기때문에, 설계로 모든 상황을 막아버리는 최악의 수를 두게된다.
그래서 코드를 짤때마다 설계를 변경해야하는 최악의 상황에 빠지게된다.

실무자들입자에서는 다음과 같은 경험이 있는 사람이 아니면 같이 일하고 싶어하지않는다.
그러나, 대부분의 신입들을 뽑으면 이것을 이론적으로 이해만 하는사람 대체적으로 생산성에 문제가 발생한다. 
그러므로 이러한 생산성을 갖추기위하여 프로젝트나 포트폴리오를 통하여 자신이 실무에서 어떤 대응을 해야하는지 이해하는 사람을 선호하게된다.
 

온라인게임 -> 라이브를 유지하며 기존의 코드를 유지보수. -> 엔진발전X 
싱글게임 -> 록맨1 > 2 기존의 코드를 개선시켜 새로운 작품을 만들면됨 -> 엔진발전O

WinAPI: 함수로 구성되어있음.
MFC: 마이크로소프트 기본 클래스. WinAPI의 함수를 클래스의 형태로 제공하는 것.

콜백: 뒤에서 부른다? 알수없는 곳에서 호출되고 있는 것. 함수에 주소값을 넘기면 필요할때 플랫폼(OS)에서 처리함.
콜: 함수호출.
메세지: 운영체제가 어떤 상황이 되면 보내주는 것.
WM_CREATE: 실행될때
WM_COMMAND: 버튼누를때
WM_PAINT: 창이 그려질때
WM_DESTROY: 종료될때
핸들러: 이벤트가 발생되는 조건을 지정하는 것
이벤트: 이전의 상태와 달라지는 것

오버라이딩: 
동적바인딩: 프로그램 실행 도중에 함수의 기능이 결정되는 것. (동적할당된 메모리에 따라 다름)
정적바인딩: 프로그램 실행(컴파일) 이전 함수의 기능이 결정되는것.


플렛폼: 서비스를 제공하는 주체. 예) 카카오, 네이버, 구글
ㄴ소프트웨어: 운영체제,SDK, 예) 윈도우, 안드로이드, 유니티, 아마존클라우드, 에저....
운영체제: 기기와 상관없이 운영체제가 설치되면 소프트웨어를 사용 할 수 있음.
드라이버: 운영체제에 맞게 하드웨어를 사용할수 있도록 돕는 프로그램.

오락실게임은 기판으로 제작됨. 하드웨어에 맞춰서 코드를 작성하는 시대.
기판: 오락기에 게임이 들어가있는 기판.
콘솔: 
크로스플랫폼: 
D3D의 대두: 풀스크린모드를 지원하여 모든 하드웨어를 게임이 온전하게 활용할수있도록 만듦.


빌드: 사용할 기기(플랫폼)에 맞게 실행할수있는 파일(컴파일)을 만드는 것.

SDK: 소프트웨어 개발도구


백도어: 정상적인 루트가 아닌 우회루트. 해킹할때 활용된다.

함수포인터: 함수의 주소값을 저장한다.

클라우드: 어떤 서비스를 제공하는데 그 아랫단의 로직은 중요하지않음.
클라우드게임서비스: 클라우드서비스안에서 게임이 실행됨.
DLL: 

버튼을 누르면 버튼의 텍스트를 변경하게 만든다.
데이터: 버튼 (객체) (변수)
알고리즘: 버튼을 누르면 버튼의 텍스트가 변경된다.(이벤트)

변수: 직업, 이름, 능력치 5개, 보너스포인트
이벤트: 클래스를 누르면 직업리스트가 뜬다.
스탯을 증감 시킬수 있다.
스탯을 분배하면 보너스포인트가 감소한다.
다시분배버튼 클릭시, 초기화된다.

구조를 이해하고 내가 필요한 코드를 어디에 넣어야할지 파악 할 수 있어야한다.

이벤트: 어떤사건이 일어나게되는 계기
ㄴwinAPI: 메세지(핸들러)를 발생시켜 해당 핸들러일 경우, 이벤트를 처리하도록 만듦.
ㄴMFC: 

헝가리안식표기:
콘솔을 활용한 이벤트 발생 경위추적

SDL검사:

포인터:
void포인터: 타입이 없는 포인터.
변수에 타입이 필요한 이유: 크기가 필요한 이유. 
변수에 표현범위가 있는 이유?: 이진수의 범위에 맞춰서 데이터를 맵핑되어있음.
간디가 폭력적인 이유?: 오버/언더플로우 때문
2^32 = 4g 
long Pointer: 2^32 타입의 포인터 (4g까지 표현가능)
printf할때 표현방법을 정해줘야하는 이유?
메모리는 데이터 덩어리일 뿐이고, 디코딩단계에서 어떻게 해석하느냐에 따라 달라진다.
치트엔진: 메모리를 읽어 값을 덮어쒸움.
메모리난독화: 
시리얼라이즈: 
동적할당:
정적할당: 
메모리누수: 동적할당된 메모리를 해제하지않으면, 메모리 누수가 발생하여, 할당할수없는 상태가 된다.
메모리페이징: 가용메모리는 있으나, 자투리 빈공간이 발생하여 더이상 메모리를 할당 할 수 없는 상태.

프로세스:
스레드:
테스크:
잡스케쥴러:
CPU에서 스레드 처리방식:
듀얼코어에서 게임처리방식:
멀티코어에서 게임처리방식:
오버헤드: 가장효율적인 처리시간에 비교해서 처리가 효률적이지 못해 생기는 문제
컨텍스트스위칭: 작업을 변경하기 위해서 준비하는 단계

코루틴:
비동기화프로그래밍: 같은 흐름내에서 처리하지않고 작동하는 처리로직.

캐싱:
버퍼링: 
교착상태:
선점/비선점:

static맴버는 객체없이 함수나 변수에 접근 할 수 있다.(싱글톤)
순수가상함수: 상속받는 자식클래스에서 반드시 선언해야한다.

일반화: 상속
실체화: 가상클래스를 상속받아 자식클래스를 만드는 것.
의존(사용):객채내부에 저장하지않고 사용함.
연관(has-a):객체내부에 참조를 저장함.

C/C++
객체(=인스턴스): 메모리가 할당된 클래스의 변수
SingleObject objSingle; //정적할당객체(인스턴스) 변수의 타입에 따라 삭제되는 시기가 결정
SingleObject* pObjSingle = new SingleObject(); //동적할된 객체 동적할당해제
C#
객체: 인스턴스의 참조값을 저장하는 변수 
인스턴스: 클래스를 동적할당하여 만들어진 참조된 대상
예) 독수리가 참조하는 타겟인 플레이어 인스턴스는 타겟이 발견했을때만 추적한다.
독수리가 플레이어를 추적할때, 객체: 타겟이 담길 변수 인스턴스: 플레이어오브젝트
클래스: 객체는 참조자고 객체를 사용하려면 객체를 할당하거나 참조해야한다.
class SingleObject;
SingleObject objSingle = new SingleObject()
			 객체(참조자)

구조체: 객체가 정적할당된다. 스탯: 값을 복사해서 가져가므로 공유되는 문제가 발생하지않음.
struct SingleObject;
SingleObject objSingle = new SingleObject()
			 객체(정적할당)       생성자의 호출(객체에 값을 할당)
			 
상속할때 부모의 부분을 선언하지않아도되는 이유: 부모위에 자식객체에 추가 메모리를 할당한다.

정적할당된 메모리는 스택에 할당된다.
동적할당된 메모리는 힙에 할당된다.
스택오버플로우: 정적할당된 메모리가너무 많아져 스택의 크기보다 많이 할당함.
무한재귀에 스택오버플로우가 발생한다.
단순 반복이 많은 횟수 반복될때는 재귀를 사용해서는 안된다.

재귀를 써야하는 이유: 트리 -> 탐색 -> 스택을 사용하지않게하기위해 -> 함수가 호출될때마다 지역변수가 스택에 할당되어 이전의 데이터에 접근 할수 있어서.